\documentclass[xcolor=table]{beamer}

\usepackage[serbianc]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{romannum}
%\usepackage[table,xcdraw]{xcolor}

\usefonttheme{professionalfonts}
\usetheme{boxes}

\title{Теорија типова и унификација типова}
\author{Борисав Живановић}
\date{}

\begin{document}

    \begin{frame}
        \maketitle
    \end{frame}
    
    \begin{frame}{Увод}
        \begin{itemize}
            \item Теорија типова је област математике и рачунарства која се бави формалним представљањем система типова
            \item Систем типова је формални (логички) систем правила који појмовима програмског језика додељује својство звано тип
            \begin{itemize}
                \item Појам може да буде било шта, у зависности од програмског језика
                \item Ми ћемо изучавати императивне програмске језике, те су наши појмови: литерали, изрази, функције, кориснички дефинисани типови
            \end{itemize}
            \item Систем типова је настао као један од првих покушаја аутоматске провере исправности кода
            \item Да бисмо ово разумели, потребан је кратак осврт на историју програмских језика
        \end{itemize}
    \end{frame}

    \begin{frame}{Шта је рачунар?}
        \textit{Рачунар је машина коју је могуће испрограмирати да изврши низ \textbf{аритметичких} и \textbf{логичких операција} (израчунавања) \textbf{аутоматски}.}
    \end{frame}

    \begin{frame}{Шта рачунар заиста зна да ради?}
        \begin{itemize}
            \item Језик рачунара: \textbf{скуп инструкција} (енгл. ISA, Instruction Set Architecture)
            \item Аритметичке операције: \textbf{add}, \textbf{sub}, \textbf{div}, \textbf{mul}, …
            \item Померање података:
            \begin{itemize}
                \item са улазног уређаја у меморију
                \item из меморије на излазни уређај
                \item са једне меморијске локације на другу
            \end{itemize}
            \item Условно гранање: извршавање кода уколико је логички услов испуњен
        \end{itemize}
    \end{frame}

    \begin{frame}{Шта је програм?}
        \textit{Рачунарски програм је \textbf{низ инструкција} садржаних у формату који рачунар може да \textbf{изврши}.}
    \end{frame}

    \begin{frame}{Како рачунари омогућавају аутоматизацију процеса?}
        \begin{itemize}
            \item Неопходно је да имамо формалну дефиницију процеса који желимо да аутоматизујемо - \textbf{морамо да дефинишемо алгоритам}
            \begin{itemize}
                \item сама дефиниција мора бити формална, односно мора садржати прецизан опис корака
                \item формат дефиниције не мора да буде формалан!
            \end{itemize}
            \item Формалну дефиницију морамо изразити у формату који рачунар може да изврши - \textbf{морамо да имплементирамо алгоритам}
            \item У пракси, грешке у дизајну и имплементацији су честе - \textbf{морамо да тестирамо програм}
        \end{itemize}
    \end{frame}

    \begin{frame}{Како је могуће описати алгоритам?}
        \begin{itemize}
            \item Очигледно је да је неопходно да формат буде разумљив рачунару
            \item Пожељно је да формат буде разумљив и људима
            \begin{itemize}
                \item бржа имплементација, мање грешака, мање документације
            \end{itemize}
            \item Још боље: аутоматска провера исправности програма
            \item Из овога је настала потреба за програмским језицима (и програмским преводиоцима)
            \item Програмски језици се класификују у 4 (по некима 5) генерација
        \end{itemize}
    \end{frame}
    
    \begin{frame}{\Romannum{1} генерација}
        \begin{columns}
            \column{0.38\linewidth}
            \begin{itemize}
                \item Ручно уношење инструкција и података у бинарном формату
                \item Којим грешкама је ово подложно?
            \end{itemize}
            
            \column{0.58\linewidth}
            \centering
            \includegraphics[width=0.7\textheight,keepaspectratio]{images/riscv_binary.png}
        \end{columns}
    \end{frame}
    
    \begin{frame}{\Romannum{2} генерација}
        \begin{columns}
            \column{0.38\linewidth}
            \begin{itemize}
                \item Инструкције су представљене својим симболичким називом
                \item Какво побољшање ово представља?
                \item Који недостаци су и даље присутни?
                \item Које типове уочавамо?
            \end{itemize}
            
            \column{0.58\linewidth}
            \centering
            \includegraphics[width=0.7\textheight,keepaspectratio]{images/riscv_asm.png}
        \end{columns}
    \end{frame}
    
    \begin{frame}{\Romannum{3} генерација}
        \begin{columns}
            \column{0.38\linewidth}
            \begin{itemize}
                \item Структура програма слична стаблу
                \item Ограничен приступ меморији
                \item Ограничена слобода у условном гранању
                \item Подела на \textbf{исказе} и \textbf{изразе}
            \end{itemize}
            
            \column{0.58\linewidth}
            \centering
            \includegraphics[width=0.7\textheight,keepaspectratio]{images/c.jpg}
        \end{columns}
    \end{frame}
    
    \begin{frame}{Теорија и пракса}
        \begin{columns}
            \column{0.48\linewidth}
            \begin{itemize}
                \item На најнижем нивоу апстракције, тип представља бинарни формат и правила за његово тумачење
                \item Ограничење је потребно како би се извршавао искључиво код који уме да интерпретира садржај на исправан начин
            \end{itemize}
            
            \column{0.48\linewidth}
            \begin{itemize}
                \item На вишем нивоу апстракције, тип представља скуп дозвољених вредности и дозвољених операција
                \item Ограничење је потребно како би се извршавале операције искључиво над семантички компатибилним ентитетима
            \end{itemize}
        \end{columns}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{Мутабилност}
        \begin{itemize}
            \item Мутабилност је појам који постоји у рачунарству, али не постоји у математици
            \item Математика познаје само вредности
            \item Вредности могу да припадају скуповима и променљиве могу да имају одређену вредност
            \item Вредности које припадају скупу су унапред задате дефиницијом скупа
            \item Међутим, природа \textbf{променљивости} саме вредности није дефинисана!
            \item Сматра се да је сама вредност \textbf{целовита} и \textbf{непроменљива}, док је могуће да променљива има различите вредности!
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Рачунарство такође познаје појам променљиве и вредности, али уводи и једно својство које сведочи о променљивости саме вредности
            \item Речником рачунарства, вредности у математици су имутабилне
            \item Више променљивих може да показује на исту вредност (показивачи), због чега измена саме вредности постаје видљива преко различитих променљивих!
            \item У рачунарству постоји ограничење задато хардвером (и у крајњој граници, законима физике) које захтева увођење оваквог својства
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Прости типови заузимају мало простора, због чега је њихово складиштење на стеку и у регистрима једноставно
            \item Креирање копија вредности простих типова је једноставно и брзо
            \item Сложени типови заузимају далеко више простора и најчешће се складиште на хипу
            \item Стање мутабилних објеката је могуће мењати и након креирања
            \item Мутабилност побољшава перформансе, али уноси непредвидивост
            \begin{itemize}
                \item имате ли идеју како?
            \end{itemize}
            \item Мутабилност утиче на дизајн система типова!
            \begin{itemize}
                \item више речи о овоме нешто касније
            \end{itemize}
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Мутабилни објекти}
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/mut0.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Мутабилни објекти}
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/mut1.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Мутабилни објекти}
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/mut2.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Имутабилни објекти}
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/imut0.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Имутабилни објекти}
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/imut1.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Имутабилни објекти}
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/imut2.png}
        \end{figure}
    \end{frame}

    \begin{frame}{Теорија типова и теорија скупова}
        \begin{itemize}
            \item Једнакост типова осигурава исправност програма
            \item Да ли отежава писање програма?
            \begin{itemize}
                \item у стварном свету, уочавамо сличност између различитих појмова и облика
                \item некада су ти појмови довољно слични да можемо да занемаримо разлике
                \item пример: потребан нам је аутомобил, али нас не занима произвођач
            \end{itemize}
            \item Тип је појам сродан скупу
            \item Ако постоје подскупови, да ли постоје и подтипови?
            \item Шта описују подскупови, а шта би описивали подтипови?
            \item Релација подтипа је слична релацији подскупа!
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Конвертибилност типова (релација подтипа)}
        \begin{itemize}
            \item Кажемо да је \begin{math}A \leq B\end{math} уколико је \begin{math}A\end{math} конвертибилно у \begin{math}B\end{math}
            \begin{itemize}
                \item \begin{math}A \leq B\end{math} \textbf{(рефлексивност)}
                \item \begin{math}A \leq B \wedge B \leq C \Rightarrow A \leq C\end{math} \textbf{(транзитивност)}
                \item \begin{math}A \leq B \wedge B \leq A \Rightarrow A = B\end{math} \textbf{(антисиметричност)}
            \end{itemize}
            \item Релација подтипа је релација парцијалног поретка!
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Шта одређује конвертибилност типова?}
        \begin{itemize}
            \item Правила која дефинишу конвертибилност типова су одлука дизајнера система типова
            \item Главни водич је тип \begin{math}A\end{math} мора да садржи све вредности које подржава \begin{math}B\end{math} као и да приликом имплицитне конверзије не долази до губитка података
            \begin{itemize}
                \item Релативан појам: скуп целих бројева је подскуп скупа реалних бројева у математици, док је у програмирању могућ губитак приликом претварања целобројне вредности у вредност са покретним зарезом
                \item Неки програмски језици ово игноришу, док други ово сматрају за грешку и захтевају експлицитну конверзију целобројног типа
            \end{itemize}
            \item Додатно: мутабилност не сме да изазове грешке приликом извршавања програма
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item За просте типове, конвертибилност је дефинисана правилима система типова
            \item За сложене типове, конвертибилност је релацијом између сложених типова (коју задаје корисник) и/или у односу на садржај (правила дефинише систем типова)
            \begin{itemize}
                \item више речи о овоме нешто касније
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Закључивање типова}
        \begin{itemize}
            \item До сада смо разумели појам типа, система типова и релације подтипа
            \item Како можемо да стечено знање употребимо за решавање полазног проблема: одређивање исправности израза?
            \item Као и сваки формални систем, и систем типова се састоји од аксиома и правила
            \item Идеја: типови простих израза (литерали и променљиве) су познати (аксиоми), а тип сложеног израза је могуће закључити уколико су подизрази одговарајућих типова (правила)
        \end{itemize}
    \end{frame}

    \begin{frame}{Правила}
        \begin{itemize}
            \item Бинарни изрази:
            \begin{itemize}
                \item оба подизраза морају да имају заједнички тип у који су конвертибилни како би операција била могућа
                \item резултат бинарне аритметичке операције је заједничког типа
                \item резултат бинарне логичке или релацине операције је булова вредсноти
            \end{itemize}
            \item Позив функције:
            \begin{itemize}
                \item евалуација позива функције враћа вредност типа повратног типа функције
                \item шта је још потребно да би позив био могућ?
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Сложени типови}
        \begin{itemize}
            \item До сада смо разумели просте типове као и њихову примену
            \item Уочавамо потребу за креирањем сложених типова
            \begin{itemize}
                \item једноставан пример: желимо обраду над скупом простих типова
                \item напреднији пример: желимо да ентитете из стварног света представимо у програмима, уз задржавање правила за аутоматску проверу исправности
                \item додатно: постоји потреба да ентитете програмског језика (попут фунцкија) опишемо типом, како би могли да их обрађујемо на исти начин као и корисничке типове
            \end{itemize}
            \item Како бисмо могли да креирамо овакве типове?
        \end{itemize}
    \end{frame}

    \begin{frame}{Конструктор типа}
        \begin{itemize}
            \item Конструктор типа омогућава креирање новог типа користећи претходно дефинисане типове
            \item Подсетник: систем типова дефинише основне типове
            \item Додатно: систем типова дефинише конструкторе типова
            \item Омогућено је произвољно комбиновање типова без обзира на контекст
            \begin{itemize}
                \item аксиоми и правила система типова омогућавају проверу исправности употребе у односу на релацију подтипа
            \end{itemize}
            \item Релација подтипа је дефинисана само за типове који су инстанцирани од сродних конструктора типова
             \begin{itemize}
                \item физика: није могуће поредити килограме и километре
                \item народски речено: не треба да се мешају бабе и жабе
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Низови}
        \begin{itemize}
            \item Низови су најједноставнији пример сложеног типа
            \item У пракси, честа је потреба за обрадом колекције података
            \item Желимо да спречимо складиштење произвољних вредности како би омогућили униформну обраду
            \item Да ли је услов за униформну обраду једнакост типова (\begin{math}=\end{math}) или релација подтипа (\begin{math}\leq\end{math})?
            \item Можемо ли да упоредимо два типа низова?
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item У низ \begin{math}t: T[]\end{math} можемо да ускладиштимо вредност \begin{math}x: X\end{math} уколико \begin{math}X \leq T\end{math}
            \begin{itemize}
                \item \begin{math}T\end{math} представља горњу границу типа вредности у низу!
            \end{itemize}
            \item У променљиву \begin{math}y: A[]\end{math} можемо да ускладиштимо низ \begin{math}x: B[]\end{math} уколико је \begin{math}B \leq A\end{math}
            \begin{itemize}
                \item тип низа је коваријантан у односу на тип \begin{math}T\end{math}
                \item да ли морамо да водимо рачуна и о дужини низа?
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Коваријантност типова}
        \textit{Сложени тип \begin{math}{A\mathord{<}T\mathord{>}}\end{math} је коваријантан у односу на тип параметра \begin{math}T\end{math} уколико важи \begin{math}{A\mathord{<}X\mathord{>} \leq A\mathord{<}Y\mathord{>}}\end{math} за \begin{math}X \leq Y\end{math}}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{Варијантност и мутабилност}
        \begin{itemize}
            \item Имутабилни низови су очигледно коваријантни у односу на \begin{math}T\end{math}
            \item Проблем: шта се дешава уколико су низови мутабилни?
        \end{itemize}
        
        \framebreak
        
        \begin{math}
        A \leq B \leq C
\newline
\newline
a: A[] = [A, A, A]
\newline
b: B[] = a
\newline
\newline
b.add(B)
\newline
\newline
\text{Грешка: није могуће сачувати вредност} \newline B\space \text{у објекту типa} A \text{јер не важи} B \leq A\text{!}
        \end{math}
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/arr0.png}
        \end{figure}
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/arr1.png}
        \end{figure}
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/arr2.png}
        \end{figure}
        
        \framebreak
        
        \begin{itemize}
            \item Дошло је до грешке приликом извршавања кода
            \item Систем типова је то морао да спречи!
            \item Могућа решења:
            \begin{itemize}
                \item обавезно копирање низа (имутабилност)
                \item инваријантност у односу на \begin{math}T\end{math}
            \end{itemize}
        \end{itemize}
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/arr0.png}
        \end{figure}
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/arr11.png}
        \end{figure}
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[height=0.7\textheight,keepaspectratio]{images/arr21.png}
        \end{figure}
    \end{frame}

    \begin{frame}{Структуре}
        \begin{itemize}
            \item Структура садржи именоване вредности (поља) чији тип може бити произвољан тип, укључујући и саму структуру из дефиниције (рекурзија је дозвољена)
            \item Које услове би требало да задовољи структура \begin{math}s: B\end{math} како би важило \begin{math}B \leq A\end{math}?
            \item Проблем: мутабилност
            \begin{itemize}
                \item мутабилне структуре такође морају да буду инваријантне у односу на типове поља
                \item имутабилне структуре могу да буду варијантне
            \end{itemize}
            \item Потребно је обратити пажњу на називе поља и њихове типове
            \item Мишљења о томе како би ту пажњу требало обратити су подељена
        \end{itemize}
    \end{frame}

    \begin{frame}{Номинални системи типова}
        \textit{У номиналном систему типова, релације између сложених типова су задате приликом конструкције типова употребом ознака типова.}
    \end{frame}

    \begin{frame}{Структурални системи типова}
        \textit{У структуралном систему типова, релације између сложених типова се одређују приликом употребе типа, поређењем садржаја очекиваног и употребљеног типа.}
    \end{frame}

    \begin{frame}[allowframebreaks]{Структуре (наставак)}
        \begin{itemize}
            \item Интуиција: уколико је вредност типа \begin{math}B\end{math} могуће сачувати у \begin{math}a: A\end{math} уколико важи \begin{math}B \leq A\end{math}, да ли је правило могуће генерализовати и применити на поља структуре?
            \item Структуре су коваријантне у односу на тип појединачних поља
            \begin{itemize}
                \item поредак важи искључиво за иста поља (поља истог имена)
            \end{itemize}
            \item Иста општа правила важе и у номиналним и у структуралним системима типова
            \item Различит је начин на који се провера спроводи
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item У номиналним системима типова, приликом конструкције типова се проверава да ли поља задовољавају релације у складу са осталим релацијама подтипа које је корисник задао
            \item У структуралним системима типова, приликом употребе типа у одређеном контексту се проверава да ли поља задовољавају релације у складу са релацијом између доступног и траженог типа која би требало да буде задовољена
            \item У пракси, системи типова често комбинују елементе оба приступа
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Функције}
        \begin{itemize}
            \item Тип функције је сложени тип који се састоји од типа параметера и типа повратне вредности
            \item Не треба мешати тип функције и тип повратне вредности функције!
            \item У језицима у којима функције представљају \textit{грађане првог реда}, функције је могуће чувати у променљивама и вратити као тип израза
            \item Како можемо да дефинишемо релацију поретка?
            \item Да ли је тип функције боље посматрати и описивати номиналним или структуралним приступом?
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Интуиција: враћање вредности је једнако додели, типови функција су коваријантни у односу на тип повратне вредности
            \item Да ли на исти начин можемо да посматрамо и типове аргумената?
            \item Може ли интуиција да нас превари?
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Прослеђивање аргумената (конкретне вредности које се додељују параметрима) приликом позива фунцкије је такође једнако додели вредности
            \item Нека су \begin{math}A\end{math} и \begin{math}B\end{math} типови функција, а \begin{math}a\end{math} и \begin{math}b\end{math} променљиве
            \item Нека су типови свих параметара \begin{math}B\end{math} подтипови параметара \begin{math}A\end{math}
            \item Покушајмо да \begin{math}B\end{math} доделимо у \begin{math}a\end{math} и извршимо позив функције
        \end{itemize}
        
        \framebreak
        
        \begin{math}
X 
\newline
Y \le X
\newline
Z \le X
\newline
A: (p: X) \to X
\newline
B: (p: Y) \to Z
\newline
\newline
a: A = some\_B\_func
\newline
a(new\;Z)
\newline
\newline
        \end{math}
Грешка!

\begin{math}some\_B\_func\end{math} очекује \begin{math}type(p) \leq Y\end{math}, али \begin{math}A\end{math} дозвољава \begin{math}type(p) \leq X\end{math}!

Тип \begin{math}Z\end{math} не задовољава услов задат од стране \begin{math}some\_B\_func\end{math}!
        \framebreak

        \begin{itemize}
            \item Интуиција (други покушај): како би спречили прослеђивање типа са којим функција не може да ради, неопходно је да аргументи подтипа функције буду у \begin{math}\geq\end{math} релацији у односу на аргументе надтипа функције
            \item Важи правило које је супротно од коваријантности
        \end{itemize}
    \end{frame}

    \begin{frame}{Контраваријантност типова}
    \textit{Сложени тип \begin{math}{A\mathord{<}T\mathord{>}}\end{math} је контраваријантан у односу на тип параметра \begin{math}T\end{math} уколико важи \begin{math}{A\mathord{<}X\mathord{>} \leq A\mathord{<}Y\mathord{>}}\end{math} за \begin{math}X \geq Y\end{math}}
    \end{frame}

    \begin{frame}{Функције (други покушај)}
        \begin{math}
X
\newline
Y \le X
\newline
Z \le X
\newline
Q \le Y
\newline
A: (p: Y) \to X
\newline
B: (p: X) \to Z
\newline
\newline
a: A = some\_B\_func
\newline
a(new\;Q)
\newline
\newline
        \end{math}
Релација подтипа је транзитивна!

За сваки тип \begin{math}T\end{math} за који важи \begin{math}T \leq A\end{math} такође важи \begin{math}T \leq B\end{math} уколико \begin{math}A \leq B\end{math} (односно \begin{math}B \geq A\end{math}).
    \end{frame}
    
    \begin{frame}{Функције (закључак)}
        \begin{itemize}
            \item Функције су коваријантне у односу на тип повратне вредности и контраваријантне у односу на типове параметара
            \item Вредност функције је заправо програмски код који она садржи
            \item Како ово није могуће у току извршавања програма, можемо функције да сматрамо имутабилним
            \item У теорији, можемо да слободно користимо варијантност у релацији подтипа
            \item У пракси, програмски језици често сматрају функције инваријантним у односу на типове параметара
            \item Овиме се олакшава имплементација, а исправност се не крши јер је инваријантност \textit{строжа} од варијантности!
            \item Доста програмских језика погрешно сматра функције коваријантним у односу на типове параметара! 
        \end{itemize}
    \end{frame}

    \begin{frame}{Генерички типови}
        \begin{itemize}
            \item До сада смо баратали искучиво са унапред познатим типовима
            \item Релација подтипа нам је давала одређену слободу да не морамо да знамо све детаље о коришћеним типовима
            \item Генеричко програмирање омогућава опис алгоритама који раде над типовима који су накнадно дефинисани
            \item Најчешћа примена: опште структуре података морају да омогуће складиштење свих корисничких типова, уз правило да се у инстанци генеричке колекције не мешају типови који нису компатибилни
            \begin{itemize}
                \item због чега релација подскупа није употребљива за ову проверу?
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Конструкција типова (наставак)}
        \begin{itemize}
            \item Уводи се ниво индирекције у конструкцији типова
            \item Дефиниција типа креира апстрактни тип
            \item Конструктор генеричког типа садржи параметре типова
            \item Корисник дефинише ограничења над параметрима (у виду релације подтипа)
            \item Додатно: корисник дефинише варијантност у односу на тип параметра
            \item Сви до сада наведени сложени типови могу да буду генерички типови!
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Унификација типова}
        \begin{itemize}
            \item Приликом креирања конкретног типа из апстрактног, корисник може да проследи произвољан тип
            \item Потребно је проверити да ли типови задовољавају ограничења која задаје апстрактни тип
            \item Додатно: потребно је доделити конкретне типове параметара
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Уколико систем типова не подржава релацију подтипа, поступак је једнак решавању система једначина
            \item Уколико је систем одређен, унификација је успешна
            \item Уколико је систем неодређен или немогућ, унификација је неуспешна
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Систем типова дефинише под којим условима је могуће унификовати два типа
            \begin{itemize}
                \item подсетник: номинални и структурални системи различито посматрају једнакост типова и релацију подтипа
                \item додатни подсетник: бабе и жабе
            \end{itemize}
            \item Опште правило:
            \begin{itemize}
                \item два проста типа је могуће унификовати уколико су једнаки
                \item два сложена типа је могуће унификовати уколико су једнаки и уколико је могуће унификовати све типове од којих се састоје
            \end{itemize}
            \item Поступак се примењује док не остану искључиво једначине познатих простих типова и параметара и простих типова
            \item Методом замене решавамо зависности између параметара
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Одређен систем једначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/moguc_jed.png}
        \end{figure}
    \end{frame}
    
   \begin{frame}{Немогућ систем једначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/nemoguc_jed.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Неодређен систем једначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/neodredjen_jed.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{Унификација типова (поступак)}
    \begin{math}
A,B, C
\newline
List\mathord{<}T\mathord{>}
\newline
Map\mathord{<}K, V\mathord{>}
\newline
func: (a: T1, b: T2, c: List\mathord{<}T1\mathord{>}, d: List\mathord{<}T2\mathord{>}) \to Map\mathord{<}T1, T2\mathord{>}
\newline
\newline
a = A
\newline
b = B
\newline
c = List\mathord{<}A\mathord{>}
\newline
d = List\mathord{<}B\mathord{>}
\newline
\newline
x = func(a, b, c, d)
\newline
type(x) = ? 
\end{math}
        \framebreak
        
        \begin{math}
A = T1
\newline
B = T2
\newline
List\mathord{<}A\mathord{>} = List\mathord{<}T1\mathord{>}
\newline
List\mathord{<}B\mathord{>} = List\mathord{<}T2\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
T1 = A
\newline
T2 = B
\newline
\newline
List = List
\newline
A = T1
\newline
List = List
\newline
B = T2
        \end{math}
        
        \framebreak
        
        \begin{math}
T1 = A
\newline
T2 = B
\newline
\newline
\text{Систем је одређен, унификација је успешна!}
\end{math}

\framebreak

\begin{math}
A,B, C
\newline
List\mathord{<}T\mathord{>}
\newline
Map\mathord{<}K, V\mathord{>}
\newline
func: (a: T1, b: T2, c: List\mathord{<}T1\mathord{>}, d: List\mathord{<}T2\mathord{>}) \to Map\mathord{<}T1, T2\mathord{>}
\newline
\newline
a = A
\newline
b = B
\newline
c = List\mathord{<}A\mathord{>}
\newline
d = List\mathord{<}A\mathord{>}
\newline
\newline
x = func(a, b, c, d)
\newline
type(x) = ? 
\end{math}
        \framebreak
        
        \begin{math}
A = T1
\newline
B = T2
\newline
List\mathord{<}A\mathord{>} = List\mathord{<}T1\mathord{>}
\newline
List\mathord{<}A\mathord{>} = List\mathord{<}T2\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
T1 = A
\newline
T2 = B
\newline
\newline
List = List
\newline
A = T1
\newline
List = List
\newline
A = T2
        \end{math}
        
        \framebreak
        
        \begin{math}
T1 = A
\newline
T2 = B, T2 = A
\newline
\newline
\text{Систем је немогућ, унификација је неуспешна!}
        \end{math}
        
\framebreak
        
        \begin{math}
A,B, C
\newline
List\mathord{<}T\mathord{>}
\newline
Map\mathord{<}K, V\mathord{>}
\newline
func: (a: T1, b: T2, c: List\mathord{<}T1\mathord{>}, d: List\mathord{<}T2\mathord{>}) \to Map\mathord{<}T1, T2\mathord{>}
\newline
\newline
a = A
\newline
b = B
\newline
c = List\mathord{<}A\mathord{>}
\newline
d = Map\mathord{<}A, B\mathord{>}
\newline
\newline
x = func(a, b, c, d)
\newline
type(x) = ? 
\end{math}
        \framebreak
        
        \begin{math}
A = T1
\newline
B = T2
\newline
List\mathord{<}A\mathord{>} = List\mathord{<}T1\mathord{>}
\newline
Map\mathord{<}A, B\mathord{>} = List\mathord{<}T2\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
T1 = A
\newline
T2 = B
\newline
\newline
List = List
\newline
A = T1
\newline
Map = List
\newline
\newline
\text{Унификција два различита сложена типа није могућа!}
        \end{math}
    \end{frame}

    \begin{frame}{Унификација и релација подтипа}
        \begin{itemize}
            \item Уколико систем типова подржава релацију подтипа, поступак унификације је једнак решавању система неједначина
            \item Решење има доњу и горњу границу
            \item Исправна су сва решења која су у интервалу!
            \item У пракси, бира се доња или горња граница јер резултат унификације мора да буде јединствено решење
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Системи неједначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/nejed_int.png}
        \end{figure}
    \end{frame}

    \begin{frame}[allowframebreaks]{Унификација типова (наставак)}
        \begin{itemize}
            \item Поступак можемо да посматрамо као генерализовану верзију претходног поступка
            \item Општа правила:
            \begin{itemize}
                \item два проста типа је могуће унификовати уколико пружени тип задовољава релацију у односу на тражени тип у датом контексту употребе (\begin{math}\leq, \geq, =\end{math})
                \item два сложена типа је могуће унификовати уколико пружени тип задовољава релацију у односу на тражени тип у датом контексту употребе и уколико је могуће унификовати све типове од којих се састоје
            \end{itemize}
            \item Додатно: решење постоји уколико је интервал правило одређен
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Подсетник: релација подтипа (\begin{math}\leq, \geq\end{math}) је антисиметрична, а релација једнакости (\begin{math}=\end{math}) симетрична!
            \item Због тога је потребно разликовати пружени и тражени тип
            \item Додела вредности у променљиву захтева \begin{math}\leq\end{math} зависност
            \item Прослеђивање вредности генеричком параметру захтева \begin{math}\leq, \geq, =\end{math} у зависности од варијантности
            \item Правила за свођење израза који садрже сложене типове у изразе који садрже просте типове и параметре су приблжно иста
            \item Додатно: потребно је обратити пажњу на варијатност типова у односу на одређени параметар јер утиче на смер релације подтипа!
        \end{itemize}
        
        \framebreak
        
        \begin{math}
List\mathord{<}T\mathord{>},\;\text{коваријантно у односу на} \;T
\newline
Map\mathord{<}K, V\mathord{>},\;\text{инваријантно у односу на} \;K,\newline\text{коваријантно у односу на} \;V
\newline
\newline
ArrayList \leq List
\newline
LinkedList \leq List
\newline
HashMap \leq Map
\newline
OrderedHashMap \leq Map
\newline
\newline
Q, P, R
\newline
Q \leq P \leq R
\newline
\newline
K, L, M
\newline
K \leq L \leq M
        \end{math}
        
        \framebreak
        
        \begin{math}
A(p_1: List\mathord{<}X\mathord{>},\;p_2: Map\mathord{<}X, Y\mathord{>})\to Y
\newline
a_1 = LinkedList\mathord{<}Q\mathord{>}
\newline
a_2 = HashMap\mathord{<}Q, P\mathord{>}
\newline
\newline
res = A(a_1, a_2)
\newline
X, Y = \;?
        \end{math}
        
        \framebreak
        
        \begin{math}
type(a_1) \leq type(p_1)
\newline
type(a_2) \leq type(p_2)
\newline
        \end{math}
        
        Прослеђивање аргумента функцији захтева да пружени тип буде подтип траженог типа (\begin{math}\leq\end{math}).
        
        \framebreak
        
        \begin{math}
LinkedList\mathord{<}Q\mathord{>} \leq List\mathord{<}X\mathord{>}
\newline
HashMap\mathord{<}Q, P\mathord{>} \leq Map\mathord{<}X, Y\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList \leq List
\newline
Q \leq X
\newline
HashMap \leq Map
\newline
Q = X
\newline
P \leq Y
\newline
        \end{math}
        
        Приликом свођења на простији облик, сложени типови су задржали релацију подтипа (\begin{math}\leq\end{math}).
        \newline\newline
        Код параметара који су коваријантни, услов је да задовољавају релацију подтипа (\begin{math}\leq\end{math}).
        \newline\newline
        Код параметара који су инваријантни, услов је да задовољавају релацију једнакости (\begin{math}=\end{math}).
        
        \framebreak
        
        \begin{math}
Q \leq X
\newline
Q = X
\newline
P \leq Y
\newline
        \end{math}
        
        Унификација је успешна!
        \newline\newline
        Познати типови су задовољили задата ограничења, а интервал решења непознатих типова је исправан.
        \newline\newline
        Из интервала по потреби бирамо горњу или доњу границу (задаје се као додатно ограничење).
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/unip1.png}
        \end{figure}
        
        \framebreak
        
        \begin{math}
A(p_1: List\mathord{<}X\mathord{>},\;p_2: Map\mathord{<}X, Y\mathord{>})\to Y
\newline
a_1 = LinkedList\mathord{<}Q\mathord{>}
\newline
a_2 = HashMap\mathord{<}P, R\mathord{>}
\newline
\newline
res = A(a_1, a_2)
\newline
X, Y = \;?
        \end{math}
        
        \framebreak
        
        \begin{math}
type(a_1) \leq type(p_1)
\newline
type(a_2) \leq type(p_2)
\newline
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList\mathord{<}Q\mathord{>} \leq List\mathord{<}X\mathord{>}
\newline
HashMap\mathord{<}P, R\mathord{>} \leq Map\mathord{<}X, Y\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList \leq List
\newline
Q \leq X
\newline
HashMap \leq Map
\newline
P = X
\newline
R \leq Y
\newline
        \end{math}
        
        \framebreak
        
        \begin{math}
Q \leq X
\newline
P = X
\newline
R \leq Y
\newline
        \end{math}
        
        Унификација је успешна!
        \newline\newline
        Уочавамо да иако су два различита типа прослеђења на месту на којем је параметар \begin{math}X\end{math}, гледамо који тип задовољава оба ограничења.
        \newline\newline
        Тако параметар \begin{math}X\end{math} постаје јединствено одређен тип!
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/unip2.png}
        \end{figure}
        
        \framebreak
        
        \begin{math}
A(p_1: List\mathord{<}X\mathord{>},\;p_2: Map\mathord{<}X, Y\mathord{>})\to Y
\newline
a_1 = LinkedList\mathord{<}Q\mathord{>}
\newline
a_2 = ArrayList\mathord{<}K\mathord{>}
\newline
\newline
res = A(a_1, a_2)
\newline
X, Y = \;?
        \end{math}
        
        \framebreak
        
        \begin{math}
type(a_1) \leq type(p_1)
\newline
type(a_2) \leq type(p_2)
\newline
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList\mathord{<}Q\mathord{>} \leq List\mathord{<}X\mathord{>}
\newline
ArrayList\mathord{<}K\mathord{>} \leq Map\mathord{<}X, Y\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList \leq List
\newline
Q \leq X
\newline
ArrayList \leq Map
\newline
        \end{math}
        
        Дошло је до грешке!
        \newline\newline
        Није могуће унификовати два сложена типа чији конструктор типова није сродан!
        
        \framebreak
        
        \begin{math}
A(p_1: List\mathord{<}X\mathord{>},\;p_2: Map\mathord{<}X, Y\mathord{>})\to Y
\newline
a_1 = LinkedList\mathord{<}Q\mathord{>}
\newline
a_2 = HashMap\mathord{<}K, P\mathord{>}
\newline
\newline
res = A(a_1, a_2)
\newline
X, Y = \;?
        \end{math}
        
        \framebreak
        
        \begin{math}
type(a_1) \leq type(p_1)
\newline
type(a_2) \leq type(p_2)
\newline
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList\mathord{<}Q\mathord{>} \leq List\mathord{<}X\mathord{>}
\newline
HashMap\mathord{<}K, P\mathord{>} \leq Map\mathord{<}X, Y\mathord{>}
        \end{math}
        
        \framebreak
        
        \begin{math}
LinkedList \leq List
\newline
Q \leq X
\newline
HashMap \leq Map
\newline
K = X
\newline
P \leq Y
        \end{math}
        
        \framebreak
        
        \begin{math}
Q \leq X
\newline
K = X
\newline
R \leq Y
\newline
        \end{math}
        
        Унификација је неуспешна!
        \newline\newline
        Не постоји тип који задовољава ограничења која се захтевају од параметра \begin{math}X\end{math}.
        \newline\newline
        Интервал решења \begin{math}X\end{math} није исправан јер типови \begin{math}Q\end{math} и \begin{math}K\end{math} нису у никаквој релацији.
        \newline\newline
        Доња граница интервала мора да буде мања или једнака горњој граници како би интервал био исправан.
        
        \framebreak
        
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/unip3.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{Имплементација}
        \begin{itemize}
            \item Приказани модел тражења интервала решења преко преклапања решења на оси је погодан за разумевање од стране људи
            \item Могуће га је имплементирати као алгоритам, али приказани облик није најпогоднији
            \item Уместо накнадног тражења интервала из ограничења, једноставније је интервал тражити у лету
            \item Подсетник: решење има горњу и доњу границу
            \item Ограничење које смо уврстили у интервал можемо да уклонимо из скупа нерешених ограничења
            \item Унификација је успешна уколико су сва ограничења разрешена успешно
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Нека је \begin{math}X\end{math} непознат тип, а \begin{math}[lower, upper]\end{math} интервал решења
            \item Интервал је исправан уколико важи \begin{math}lower \leq upper\end{math}
            \item Горња или доња граница могу да недостају
            \item У решавању бројчаних неједначина крајње границе интервала су \begin{math}+\infty\end{math} и \begin{math}-\infty\end{math}
            \item У неједначинама типова, обиласком хијерархије типова се проналазе доња и горња граница у складу са релацијом подтипа
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Ограничење \begin{math}X \geq T\end{math}:
            \begin{itemize}
                \item како би интервал био исправан, мора да важи \begin{math}T \leq upper\end{math}
                \item уколико \begin{math}lower\end{math} нема вредност, доња граница добија нову вредност \begin{math}lower = T\end{math}
                \item уколико \begin{math}T \leq lower\end{math}, доња граница задржава стару вредност
                \item уколико \begin{math}T \geq lower\end{math}, доња граница добија нову вредност \begin{math}lower = T\end{math}
            \end{itemize}
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Ограничење \begin{math}X \leq T\end{math}:
            \begin{itemize}
                \item како би интервал био исправан, мора да важи \begin{math}T \geq lower\end{math}
                \item уколико \begin{math}upper\end{math} нема вредност, горња граница добија нову вредност \begin{math}upper = T\end{math}
                \item уколико \begin{math}T \geq upper\end{math}, горња граница задржава стару вредност
                \item уколико \begin{math}T \leq upper\end{math}, горња граница добија нову вредност \begin{math}upper = T\end{math}
            \end{itemize}
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Проблем: како уврстити ограничење \begin{math}=\end{math}?
            \item Подсетник: релација подтипа је антисиметрична (\begin{math}A \leq B \wedge B \leq A \Rightarrow A = B\end{math})!
            \item Уместо ограничења \begin{math}A = B\end{math} уводимо пар ограничења: \begin{math}A \leq B\end{math} и \begin{math}B \leq A\end{math}
            \item У пракси, ово се ради у једном кораку
            \item Интервал тражимо по правилима дефинисаним за ограничења \begin{math}\leq\end{math} и \begin{math}\geq\end{math}
        \end{itemize}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{Закључак}
        \begin{itemize}
            \item Као покушај налажења заједничког језика разумљивог и рачуанрима и људима, настали су виши програмски језици
            \item Додатна замисао је била аутоматска провера исправности програма
            \item Једнакост између очекиваног и обезбеђеног типа је била довољан услов да се спречи неисправна употреба вредности у програму
            \item Како појмови у природи показују сличност, замисао је била представити ту сличност кроз релацију подтипа
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Сложени типови су неопходни како би се описале појаве из природе, као и појаве из света рачунарства
            \item Релација подтипа код сложених типова зависи од конструктора типова и од садржаја самих типова
            \item За неке типове је природно да релација између садржаних типова директно одговара релацији између сложених типова (коваријантност), док је за одређене типове она супротна (контраваријантност)
            \item За разлику од математике, рачунарство познаје појам мутабилности
            \item Иако типови природно показују варијантност, мутабилност је често значајно ограничава
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Релација подтипа не обезбеђује довољну флексибилност за типове попут листа и мапа
            \item Генерички типови омогућавају да корисник при инстанцирању типа зада прецизнија ограничења типа
            \item Код генеричких типова, потребно је обавити поступак унификације како би одредили вредности непознатих параметара
            \item Уколико систем типова подржава само једнакост типова, поступак је једнак решавању система једначина
            \item Уколико систем типова подржава релацију, поступак је једнак решавању система неједначина
        \end{itemize}
    \end{frame}
    
    \begin{frame}[allowframebreaks]{Литература}
        \begin{itemize}
            \item Type Checking (Part 1), Keith Schwarz \url{https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/lectures/09/Slides09.pdf}
            \item Type Checking (Part 2), Keith Schwarz \url{https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/lectures/10/Slides10.pdf}
            \item Everything You Always Wanted to Know About Type Inference - And a Little Bit More, Robert Griesemer \url{https://go.dev/blog/type-inference}
            \item Unification in Chalk (part 1), Niko Matsakis \url{https://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/}
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item Type unification rules (The Go Programming Language Specification) \url{https://tip.golang.org/ref/spec\#Type_unification_rules}
            \item Kotlin type constraints (Kotlin language specification), Marat Akhin \& Mikhail Belyaev \url{https://kotlinlang.org/spec/kotlin-type-constraints.html}
            \item Type inference (Rust Compiler Development Guide) \url{https://rustc-dev-guide.rust-lang.org/type-inference.html}
        \end{itemize}
    \end{frame}
\end{document}
