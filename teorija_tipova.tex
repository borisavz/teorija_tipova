\documentclass[xcolor=table]{beamer}

\usepackage[serbianc]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{romannum}
%\usepackage[table,xcdraw]{xcolor}

\usefonttheme{professionalfonts}
\usetheme{boxes}

\title{Теорија типова и унификација типова}
\author{Борисав Живановић}
\date{}

\begin{document}

    \begin{frame}
        \maketitle
    \end{frame}
    
    \begin{frame}{Увод}
        \begin{itemize}
            \item Теорија типова је област математике и рачунарства која се бави формалним представљањем система типова
            \item Систем типова је формални (логички) систем правила који појмовима програмског језика додељује својство звано тип
            \begin{itemize}
                \item Појам може да буде било шта, у зависности од програмског језика
                \item Ми ћемо изучавати императивне програмске језике, те су наши појмови: литерали, изрази, функције, кориснички дефинисани типови
            \end{itemize}
            \item Систем типова је настао као један од првих покушаја аутоматске провере исправности кода
            \item Да бисмо ово разумели, потребан је кратак осврт на историју програмских језика
        \end{itemize}
    \end{frame}

    \begin{frame}{Шта је рачунар?}
        \textit{Рачунар је машина коју је могуће испрограмирати да изврши низ \textbf{аритметичких} и \textbf{логичких операција} (израчунавања) \textbf{аутоматски}.}
    \end{frame}

    \begin{frame}{Шта рачунар заиста зна да ради?}
        \begin{itemize}
            \item Језик рачунара: \textbf{скуп инструкција} (енгл. ISA, Instruction Set Architecture)
            \item Аритметичке операције: \textbf{add}, \textbf{sub}, \textbf{div}, \textbf{mul}, …
            \item Померање података:
            \begin{itemize}
                \item са улазног уређаја у меморију
                \item из меморије на излазни уређај
                \item са једне меморијске локације на другу
            \end{itemize}
            \item Условно гранање: извршавање кода уколико је логички услов испуњен
        \end{itemize}
    \end{frame}

    \begin{frame}{Шта је програм?}
        \textit{Рачунарски програм је \textbf{низ инструкција} садржаних у формату који рачунар може да \textbf{изврши}.}
    \end{frame}

    \begin{frame}{Како рачунари омогућавају аутоматизацију процеса?}
        \begin{itemize}
            \item Неопходно је да имамо формалну дефиницију процеса који желимо да аутоматизујемо - \textbf{морамо да дефинишемо алгоритам}
            \begin{itemize}
                \item сама дефиниција мора бити формална, односно мора садржати прецизан опис корака
                \item формат дефиниције не мора да буде формалан!
            \end{itemize}
            \item Формалну дефиницију морамо изразити у формату који рачунар може да изврши - \textbf{морамо да имплементирамо алгоритам}
            \item У пракси, грешке у дизајну и имплементацији су честе - \textbf{морамо да тестирамо програм}
        \end{itemize}
    \end{frame}

    \begin{frame}{Како је могуће описати алгоритам?}
        \begin{itemize}
            \item Очигледно је да је неопходно да формат буде разумљив рачунару
            \item Пожељно је да формат буде разумљив и људима
            \begin{itemize}
                \item бржа имплементација, мање грешака, мање документације
            \end{itemize}
            \item Још боље: аутоматска провера исправности програма
            \item Из овога је настала потреба за програмским језицима (и програмским преводиоцима)
            \item Програмски језици се класификују у 4 (по некима 5) генерација
        \end{itemize}
    \end{frame}
    
    \begin{frame}{\Romannum{1} генерација}
        \begin{columns}
            \column{0.38\linewidth}
            \begin{itemize}
                \item Ручно уношење инструкција и података у бинарном формату
                \item Којим грешкама је ово подложно?
            \end{itemize}
            
            \column{0.58\linewidth}
            \centering
            \includegraphics[width=0.7\textheight,keepaspectratio]{images/riscv_binary.png}
        \end{columns}
    \end{frame}
    
    \begin{frame}{\Romannum{2} генерација}
        \begin{columns}
            \column{0.38\linewidth}
            \begin{itemize}
                \item Инструкције су представљене својим симболичким називом
                \item Какво побољшање ово представља?
                \item Који недостаци су и даље присутни?
                \item Које типове уочавамо?
            \end{itemize}
            
            \column{0.58\linewidth}
            \centering
            \includegraphics[width=0.7\textheight,keepaspectratio]{images/riscv_asm.png}
        \end{columns}
    \end{frame}
    
    \begin{frame}{\Romannum{3} генерација}
        \begin{columns}
            \column{0.38\linewidth}
            \begin{itemize}
                \item Структура програма слична стаблу
                \item Ограничен приступ меморији
                \item Ограничена слобода у условном гранању
                \item Подела на \textbf{исказе} и \textbf{изразе}
            \end{itemize}
            
            \column{0.58\linewidth}
            \centering
            \includegraphics[width=0.7\textheight,keepaspectratio]{images/c.jpg}
        \end{columns}
    \end{frame}
    
    \begin{frame}{Теорија и пракса}
        \begin{columns}
            \column{0.48\linewidth}
            \begin{itemize}
                \item На најнижем нивоу апстракције, тип представља бинарни формат и правила за његово тумачење
                \item Ограничење је потребно како би се извршавао искључиво код који уме да интерпретира садржај на исправан начин
            \end{itemize}
            
            \column{0.48\linewidth}
            \begin{itemize}
                \item На вишем нивоу апстракције, тип представља скуп дозвољених вредности и дозвољених операција
                \item Ограничење је потребно како би се извршавале операције искључиво над семантички компатибилним ентитетима
            \end{itemize}
        \end{columns}
    \end{frame}

    \begin{frame}{Теорија типова и теорија скупова}
        \begin{itemize}
            \item Тип је појам сродан скупу
            \item Ако постоје подскупови, да ли постоје и подтипови?
            \item Шта описују подскупови, а шта би описивали подтипови?
            \item Релација подтипа је слична релацији подскупа!
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Шта одређује конвертибилност типова?}
        \begin{itemize}
            \item Правила која дефинишу конвертибилност типова су одлука дизајнера система типова
            \item Главни водич је тип А мора да садржи све вредности које подржава Б као и да приликом имплицитне конверзије не долази до губитка података
            \begin{itemize}
                \item Релативан појам: скуп целих бројева је подскуп скупа реалних бројева у математици, док је у програмирању могућ губитак приликом претварања целобројне вредности у вредност са покретним зарезом
                \item Неки програмски језици ово игноришу, док други ово сматрају за грешку и захтевају експлицитну конверзију целобројног типа
            \end{itemize}
        \end{itemize}
        
        \framebreak
        
        \begin{itemize}
            \item За просте типове, конвертибилност је дефинисана правилима система типова
            \item За сложене типове, конвертибилност је релацијом између сложених типова (коју задаје корисник) и/или у односу на садржај (правила дефинише систем типова)
            \begin{itemize}
                \item Више речи о овоме нешто касније
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Закључивање типова}
        \begin{itemize}
            \item До сада смо разумели појам типа, система типова и релације подтипа
            \item Како можемо да стечено знање употребимо за решавање полазног проблема: одређивање исправности израза?
            \item Као и сваки формални систем, и систем типова се састоји од аксиома и правила
            \item Идеја: типови простих израза (литерали и променљиве) су познати (аксиоми), а тип сложеног израза је могуће закључити уколико су подизрази одговарајућих типова (правила)
        \end{itemize}
    \end{frame}

    \begin{frame}{Правила}
        \begin{itemize}
            \item Бинарни изрази:
            \begin{itemize}
                \item оба подизраза морају да имају заједнички тип у који су конвертибилни како би операција била могућа
                \item резултат бинарне аритметичке операције је заједничког типа
                \item резултат бинарне логичке или релацине операције је булова вредсноти
            \end{itemize}
            \item Позив функције:
            \begin{itemize}
                \item евалуација позива функције враћа вредност типа повратног типа функције
                \item шта је још потребно да би позив био могућ?
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Сложени типови}
        \begin{itemize}
            \item До сада смо разумели просте типове као и њихову примену
            \item Уочавамо потребу за креирањем сложених типова
            \begin{itemize}
                \item једноставан пример: желимо обраду над скупом простих типова
                \item напреднији пример: желимо да ентитете из стварног света представимо у програмима, уз задржавање правила за аутоматску проверу исправности
                \item додатно: постоји потреба да ентитете програмског језика (попут фунцкија) опишемо типом, како би могли да их обрађујемо на исти начин као и корисничке типове
            \end{itemize}
            \item Како бисмо могли да креирамо овакве типове?
        \end{itemize}
    \end{frame}

    \begin{frame}{Конструктор типа}
        \begin{itemize}
            \item Конструктор типа омогућава креирање новог типа користећи претходно дефинисане типове
            \item Подсетник: систем типова дефинише основне типове
            \item Додатно: систем типова дефинише конструкторе типова
            \item Омогућено је произвољно комбиновање типова без обзира на контекст
            \begin{itemize}
                \item аксиоми и правила система типова омогућавају проверу исправности употребе у односу на релацију подтипа
            \end{itemize}
            \item Како бисмо могли да креирамо овакве типове?
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Низови}
        \begin{itemize}
            \item Низови су најједноставнији пример сложеног типа
            \item У пракси, честа је потреба за обрадом колекције података
            \item Желимо да спречимо складиштење произвољних вредности како би омогућили униформну обраду
            \item Да ли је услов за униформну обраду једнакост типова () или релација подтипа ()?
            \item Можемо ли да упоредимо два типа низова?
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item У низ Т[] можемо да ускладиштимо вредност x: X уколико X <= T
            \begin{itemize}
                \item T представља горњу границу типа вредности у низу!
            \end{itemize}
            \item У променљиву y: A[] можемо да ускладиштимо низ x: B[] уколико је B <= A
            \begin{itemize}
                \item тип низа је коваријантан у односу на тип Т
                \item да ли морамо да водимо рачуна и о дужини низа?
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Коваријантност типова}
        \textit{Сложени тип \begin{math}{A\mathord{<}T\mathord{>}}\end{math} је коваријантан у односу на тип параметра \begin{math}T\end{math} уколико важи \begin{math}{A\mathord{<}X\mathord{>} \leq A\mathord{<}Y\mathord{>}}\end{math} за \begin{math}X \leq Y\end{math}}
    \end{frame}

    \begin{frame}{Структуре}
        \begin{itemize}
            \item Структура садржи именоване вредности (поља) чији тип може бити произвољан тип, укључујући и саму структуру из дефиниције (рекурзија је дозвољена)
            \item Које услове би требало да задовољи структура B како би важило B <= A?
            \item Подсетник: потребно је обратити пажњу на називе поља и њихове типове
            \item Мишљења о томе како би ту пажњу требало обратити су подељена
        \end{itemize}
    \end{frame}

    \begin{frame}{Номинални системи типова}
        \textit{...}
    \end{frame}

    \begin{frame}{Структурални системи типова}
        \textit{...}
    \end{frame}

    \begin{frame}[allowframebreaks]{Структуре (наставак)}
        \begin{itemize}
            \item Интуиција: уколико је вредност B могуће сачувати у a: A уколико важи B <= A, да ли је правило могуће генерализовати и применити на поља структуре?
            \item Структуре су коваријантне у односу на тип појединачних поља
            \begin{itemize}
                \item поредак важи искључиво за иста поља (поља истог имена)
            \end{itemize}
            \item Иста општа правила важе и у номиналним и у структуралним системима типова
            \item Различит је начин на који се провера спроводи
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item У номиналним системима типова, приликом конструкције типова се проверава да ли поља задовољавају релације у складу са осталим релацијама подтипа које је корисник задао
            \item У структуралним системима типова, приликом употребе типа у одређеном контексту се проверава да ли поља задовољавају релације у складу са релацијом између доступног и траженог типа која би требало да буде задовољена
            \item У пракси, системи типова често комбинују елементе оба приступа
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Функције}
        \begin{itemize}
            \item Тип функције је сложени тип који се састоји од типа параметера и типа повратне вредности
            \item Не треба мешати тип функције и тип повратне вредности функције!
            \item У језицима у којима функције представљају грађане првог реда, функције је могуће чувати у променљивама и вратити као тип израза
            \item Како можемо да дефинишемо релацију поретка?
            \item Да ли је тип функције боље посматрати и описивати номиналним или структуралним приступом?
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Интуиција: враћање вредности је једнако додели, типови функција су коваријантни у односу на тип повратне вредности
            \item Да ли на исти начин можемо да посматрамо и типове аргумената?
            \item Може ли интуиција да нас превари?
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Прослеђивање аргумената (конкретне вредности које се додељују параметрима) приликом позива фунцкије је такође једнако додели вредности
            \item Нека су A и B типови функција, а a и b променљиве
            \item Нека су типови свих параметара B подтипови параметара A
            \item Покушајмо да B доделимо у a и извршимо позив функције
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Интуиција (други покушај): како би спречили прослеђивање типа са којим функција не може да ради, неопходно је да аргументи подтипа функције буду у >= релацији у односу на аргументе надтипа функције
            \item Важи правило које је супротно од коваријантности
        \end{itemize}
    \end{frame}

    \begin{frame}{Контраваријантност типова}
    \textit{Сложени тип \begin{math}{A\mathord{<}T\mathord{>}}\end{math} је контраваријантан у односу на тип параметра \begin{math}T\end{math} уколико важи \begin{math}{A\mathord{<}X\mathord{>} \leq A\mathord{<}Y\mathord{>}}\end{math} за \begin{math}X \geq Y\end{math}}
    \end{frame}

    \begin{frame}{Функције (други покушај)}
        ..
    \end{frame}

    \begin{frame}{Генерички типови}
        \begin{itemize}
            \item До сада смо баратали искучиво са унапред познатим типовима
            \item Релација подтипа нам је давала одређену слободу да не морамо да знамо све детаље о коришћеним типовима
            \item Генеричко програмирање омогућава опис алгоритама који раде над типовима који су накнадно дефинисани
            \item Најчешћа примена: опште структуре података морају да омогуће складиштење свих корисничких типова, уз правило да се у инстанци генеричке колекције не мешају типови који нису компатибилни
            \begin{itemize}
                \item због чега релација подскупа није употребљива за ову проверу?
            \end{itemize}
        \end{itemize}
    \end{frame}

    \begin{frame}{Конструкција типова (наставак)}
        \begin{itemize}
            \item Уводи се ниво индирекције у конструкцији типова
            \item Дефиниција типа креира апстрактни тип
            \item Конструктор генеричког типа садржи параметре типова
            \item Корисник дефинише ограничења над параметрима (у виду релације подтипа)
            \item Додатно: корисник дефинише варијантност у односу на тип параметра
            \item Сви до сада наведени сложени типови могу да буду генерички типови!
        \end{itemize}
    \end{frame}

    \begin{frame}[allowframebreaks]{Унификација типова}
        \begin{itemize}
            \item Приликом креирања конкретног типа из апстрактног, корисник може да проследи произвољан тип
            \item Потребно је проверити да ли типови задовољавају ограничења која задаје апстрактни тип
            \item Додатно: потребно је доделити конкретне типове параметара
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Уколико систем типова не подржава релацију подтипа, поступак је једнак решавању система једначина
            \item Уколико је систем одређен, унификација је успешна
            \item Уколико је систем неодређен или немогућ, унификација је неуспешна
        \end{itemize}

        \framebreak

        \begin{itemize}
            \item Систем типова дефинише под којим условима је могуће унификовати два типа
            \begin{itemize}
                \item подсетник: номинални и структурални системи различито посматрају једнакост типова и релацију подтипа
                \item додатни подсетник: бабе и жабе
            \end{itemize}
            \item Опште правило:
            \begin{itemize}
                \item два проста типа је могуће унификовати уколико су једнаки
                \item два сложена типа је могуће унификовати уколико су једнаки и уколико је могуће унификовати све типове од којих се састоје
            \end{itemize}
            \item Поступак се примењује док не остану искључиво једначине познатих простих типова и параметара и простих типова
            \item Методом замене решавамо зависности између параметара
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Одређен систем једначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/moguc_jed.png}
        \end{figure}
    \end{frame}
    
   \begin{frame}{Немогућ систем једначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/nemoguc_jed.png}
        \end{figure}
    \end{frame}
    
    \begin{frame}{Неодређен систем једначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/neodredjen_jed.png}
        \end{figure}
    \end{frame}

    \begin{frame}{Унификација и релација подтипа}
        \begin{itemize}
            \item Уколико систем типова подржава релацију подтипа, поступак унификације је једнак решавању система неједначина
            \item Решење има доњу и горњу границу
            \item Исправна су сва решења која су у интервалу!
            \item У пракси, бира се доња или горња граница јер резултат унификације мора да буде јединствено решење
        \end{itemize}
    \end{frame}
    
    \begin{frame}{Системи неједначина}
        \begin{figure}
            \centering
            \includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{images/nejed_int.png}
        \end{figure}
    \end{frame}

    \begin{frame}[allowframebreaks]{Унификација типова (наставак)}
        \begin{itemize}
            \item Поступак можемо да посматрамо као генерализовану верзију претходног поступка
            \item Општа правила:
            \begin{itemize}
                \item два проста типа је могуће унификовати уколико A <= B
                \item два сложена типа је могуће унификовати уколиок A <= B и уколико је могуће унификовати све типове од којих се састоје
            \end{itemize}
            \item Додатно: решење постоји уколико је интервал правило одређен
            \item Правила за свођење израза који садрже сложене типове у изразе који садрже просте типове и параметре су приблжно иста
            \item Додатно: потребно је обратити пажњу на варијатност типова у односу на одређени параметар јер утиче на смер релације подтипа!
        \end{itemize}
    \end{frame}
\end{document}
