Теорија типова је област математике и рачунарства која се бави формалним представљањем система типова

Систем типова је формални (логички) систем правила који појмовима програмског језика додељује својство звано тип
  Појам може да буде било шта, у зависности од програмског језика
  Ми ћемо изучавати императивне програмске језике, те су наши појмови: литерали, изрази, функције, кориснички дефинисани типови

Систем типова је настао као један од првих покушаја аутоматске провере исправности кода

Да бисмо ово разумели, потребан је кратак осврт на историју програмских језика
-
**
**
**
-
Како је могуће описати алгоритам?

Очигледно је да је неопходно да формат буде разумљив рачунару

Пожељно је да формат буде разумљив и људима
  Бржа имплементација, мање грешака, мање документације

Још боље: аутоматска провера исправности програма

Из овога је настала потреба за програмским преводиоцима
-
1 генерација

Ручно уношење инструкција и података у бинарном формату

Којим грешкама је ово подложно?
-
2 генерација

Инструкције су представљене својим симболичким називом, а податке је (осим у бинарном) могуће задати и у декадном и хексадецималном запису

Какво побољшање ово представља?

Који недостаци су и даље присутни?

Које типове уочавамо?
-
3 генерација

Структура програма слична стаблу

Ограничен приступ меморији

Ограничена слобода у условном гранању

Подела на исказе и изразе
-
Теорија и пракса

На најнижем нивоу апстракције, тип представља бинарни формат и правила за његово тумачење

Ограничење је потребно како би се извршавао искључиво код који уме да интерпретира садржај на исправан начин

На вишем нивоу апстракције, тип представља скуп дозвољених вредности и дозвољених операција

Ограничење је потребно како би се извршавале операције искључиво над семантички компатибилним ентитетима
-
Типови

Прости типови: int, real, bool
Сложени типови:
  Низови: низ вредности истог основног типа
  Структуре:
  Класе
Генерички типови
-
Теорија типова и теорија скупова

Тип је појам сродан скупу

Ако постоје подскупови, да ли постоје и подтипови?

Шта описују подскупови, а шта би описивали подтипови?

Релација подтипа је слична релацији подскупа!
-
Конвертибилност типова

Кажемо да је A <= B уколико је A конвертибилно у B

  A <= A ()
  A <= B ^ B <= C -> A <= C
  A <= B ^ B <= A -> A = B
  
Релација подскупа је релација парцијалног поретка!
-
Шта одређује конвертибилност типова?

Правила која дефинишу конвертибилност типова су одлука дизајнера система типова

Главни водич је тип А мора да садржи све вредности које подржава Б као и да приликом имплицитне конверзије не долази до губитка података
  - Релативан појам: скуп целих бројева је подскуп скупа реалних бројева у математици, док је у програмирању могућ губитак приликом претварања целобројне вредности у вредност са покретним зарезом
  - Неки програмски језици ово игноришу, док други ово сматрају за грешку и захтевају експлицитну конверзију целобројног типа

За просте типове, конвертибилност је дефинисана правилима система типова

За сложене типове, конвертибилност је релацијом између сложених типова (коју задаје корисник) и/или у односу на садржај (правила дефинише систем типова)
 - Више речи о овоме нешто касније
-
Релација подтипа: прости типови

слика
-
Закључивање типова

До сада смо разумели појам типа, система типова и релације подтипа

Како можемо да стечено знање употребимо за решавање полазног проблема: одређивање исправности израза?

Као и сваки формални систем, и систем типова се састоји од аксиома и правила

Идеја: типови простих израза (литерали и променљиве) су познати (аксиоми), а тип сложеног израза је могуће закључити уколико су подизрази одговарајућих типова (правила)
-
Аксиоми

запис речима

формални запис
-
Правила

Бинарни изрази:
  оба подизраза морају да имају заједнички тип у који су конвертибилни како би операција била могућа
  резултат бинарне аритметичке операције је заједничког типа
  резултат бинарне логичке или релацине операције је булова вредсноти
Позив функције:
  евалуација позива функције враћа вредност типа повратног типа функције
  шта је још потребно да би позив био могућ?
-
Горња граница типа
Доња граница типа

само деф на сред слајда
-
Закључивање типова (наставак)

слика стабло израз и типови по стаблу
-
Сложени типови

До сада смо разумели просте типове као и њихову примену

Уочавамо потребу за креирањем сложених типова
  једноставан пример: желимо обраду над скупом простих типова
  напреднији пример: желимо да ентитете из стварног света представимо у програмима, уз задржавање правила за аутоматску проверу исправности
  додатно: постоји потреба да ентитете програмског језика (попут фунцкија) опишемо типом, како би могли да их обрађујемо на исти начин као и корисничке типове

Како бисмо могли да креирамо овакве типове?
-
Конструктор типова

Конструктор типа омогућава креирање новог типа користећи претходно дефинисане типове

Подсетник: систем типова дефинише основне типове

Додатно: систем типова дефинише конструкторе типова

Омогућено је произвољно комбиновање типова без обзира на контекст
  аксиоми и правила система типова омогућавају проверу исправности употребе у односу на релацију подтипа
-
Низови су најједноставнији пример сложеног типа

У пракси, честа је потреба за обрадом колекције података

Желимо да спречимо складиштење произвољних вредности како би омогућили униформну обраду

Да ли је услов за униформну обраду једнакост типова () или релација подтипа ()?

Можемо ли да упоредимо два типа низова?
-
У низ Т[] можемо да ускладиштимо вредност x: X уколико X <= T
 - T представља горњу границу типа вредности у низу!

У променљиву y: A[] можемо да ускладиштимо низ x: B[] уколико је B <= A
  - да ли морамо да водимо рачуна и о дужини низа?
  - тип низа је коваријантан у односу на тип Т
-
Коваријантност типова

Сложени тип A<T> је коваријантан у односу на тип параметра T уколико важи A<X> <= A<Y> за X <= Y
-
Структуре

Структура садржи именоване вредности (поља) чији тип може бити произвољан тип, укључујући и саму структуру из дефиниције (рекурзија је дозвољена)

Које услове би требало да задовољи структура B како би важило B <= A?

Подсетник: потребно је обратити пажњу на називе поља и њихове типове

Мишљења о томе како би ту пажњу требало обратити су подељена
-
Номинални системи типова

деф
-
Структурални системи типова

деф
-
Структуре (наставак)

Интуиција: уколико је вредност B могуће сачувати у a: A уколико важи B <= A, да ли је правило могуће генерализовати и применити на поља структуре?

Структуре су коваријантне у односу на тип појединачних поља

Поредак важи искључиво за иста поља
 - поља истог имена
-
Иста општа правила важе и у номиналним и у структуралним системима типова

Различит је начин на који се провера спроводи

У номиналним системима, приликом конструкције типова се проверава да ли поља задовољавају релације у складу са осталим релацијама подтипа које је корисник задао

У структуралним системима, приликом употребе типа у одређеном контексту се проверава да ли поља задовољавају релације у складу са релацијом између доступног и траженог типа која би требало да буде задовољена

У пракси, системи типова често комбинују елементе оба приступа
-
Функције

Тип функције је сложени тип који се састоји од типа параметера и типа повратне вредности

Не треба мешати тип функције и тип повратне вредности функције!

У језицима у којима функције представљају грађане првог реда, функције је могуће чувати у променљивама и вратити као тип израза

Како можемо да дефинишемо релацију поретка?

Да ли је тип функције боље посматрати и описивати номиналним или структуралним приступом?
-
Интуиција: враћање вредности је једнако додели, типови функција су коваријантни у односу на тип повратне вредности

Да ли на исти начин можемо да посматрамо и типове аргумената?

Може ли интуиција да нас превари?
-
Прослеђивање аргумената (конкретне вредности које се додељују параметрима) приликом позива фунцкије је такође једнако додели вредности

Нека су A и B типови функција, а a и b променљиве

Нека су типови свих параметара B подтипови параметара A

Покушајмо да B доделимо у a и извршимо позив функције
-
X
Y <= X
Z <= C
a: (p: X) -> X
b: (p: Y) -> Z

a = B
a(new Z) грешка! B очекује да type(p) <= Y, а аргумент је типа Z
-
Интуиција: како би спречили прослеђивање типа са којим функција не може да ради, неопходно је да аргументи подтипа функције буду у >= релацији у односу на аргументе надтипа функције

Важи правило које је супротно од коваријантности
-
Контраваријантност

Сложени тип A<T> је контраваријантан у односу на тип параметра T уколико важи A<X> <= A<Y> за X >= Y
-
Функције (други покушај)

X
Y <= X
Z <= C
a: (p: X) -> X
b: (p: Y) -> Z

a = B
a(new Y) B очекује type(p) <= X, услов је задовољен јер Y <= X!
-
Генерички типови

До сада смо баратали искучиво са унапред познатим типовима

Релација подтипа нам је давала одређену слободу да не морамо да знамо све детаље о коришћеним типовима

Генеричко програмирање омогућава опис алгоритама који раде над типовима који су накнадно дефинисани

Најчешћа примена: опште структуре података морају да омогуће складиштење свих корисничких типова, уз правило да се у инстанци генеричке колекције не мешају типови који нису компатибилни
-
Конструкција типова (наставак)

Уводи се ниво индирекције у конструкцији типова

Дефиниција типа креира апстрактни тип

Конструктор генеричког типа садржи параметре типова

Корисник дефинише ограничења над параметрима (у виду релације подтипа)

Додатно: корисник дефинише варијантност у односу на тип параметра

Сви до сада наведени сложени типови могу да буду генерички типови!
-
Унификација типова

Приликом креирања конкретног типа из апстрактног, корисник може да проследи произвољан тип

Потребно је проверити да ли типови задовољавају ограничења која задаје апстрактни тип

Додатно: потребно је доделити конкретне типове параметара
-
Уколико систем типова не подржава релацију подтипа, поступак је једнак решавању система једначина

Уколико је систем одређен, унификација је успешна

Уколико је систем неодређен или немогућ, унификација је неуспешна
-
Систем типова дефинише под којим условима је могуће унификовати два типа
  подсетник: номинални и структурални системи различито посматрају релацију подтипа
  додатни подсетник: бабе и жабе

Опште правило:
  два проста типа је могуће унификовати уколико су једнаки
  два сложена типа је могуће унификовати уколико су једнаки и уколико је могуће унификовати све типове од којих се састоје

Поступак се примењује док не остану искључиво једначине познатих простих типова и параметара и простих типова

Методом замене решавамо зависности између параметара
-
слајд успешна унификација
слајд неуспешна
  1. Array = Map
  2. X = Array, X = Map
-
Унификација и релација подтипа

Уколико систем типова подржава релацију подтипа, поступак унификације је једнак решавању система неједначина

Решење има доњу и горњу границу

Исправна су сва решења која су у интервалу!

У пракси, бира се доња или горња граница јер резултат унификације мора да буде јединствено решење
-
Унификација (наставак)

Поступак можемо да посматрамо као генерализовану верзију претходног поступка

Општа правила
  два проста типа је могуће унификовати уколико A <= B
  два сложена типа је могуће унификовати уколиок A <= B и уколико је могуће унификовати све типове од којих се састоје

Додатно: решење постоји уколико је интервал правило одређен

Правила за свођење израза који садрже сложене типове у изразе који садрже просте типове и параметре су приблжно иста

Додатно: потребно је обратити пажњу на варијатност типова у односу на одређени параметар јер утиче на смер релације подтипа!
-
слајд неједначина са решењем интервал
слајд неједначина без решења интервал
-
слајд успешна унифиакција
слајд неуспешна
  1. спољни типови не могу да се унификују
  2. интервал решења
